/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most collections,
 *              allowing users to manage their own data (Outlets, Suppliers, Inventory, Recipes, Menus, Sales, Purchase Orders).
 *              User profiles are self-created and managed.
 *              Global collections (Allergens, Ingredient Categories) are publicly readable.
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /outlets/{outletId}: Outlets owned by users.
 * - /suppliers/{supplierId}: Suppliers managed by users.
 * - /inventory/{inventoryId}: Inventory items managed by users.
 * - /inventoryStock/{stockId}: Inventory stock levels at outlets, owned by users.
 * - /recipes/{recipeId}: Recipes created by users.
 * - /menus/{menuId}: Menus created by users.
 * - /sales/{saleId}: Sales records associated with users and outlets.
 * - /purchaseOrders/{poId}: Purchase orders created by users.
 * - /allergens/{allergenId}: Global list of allergens.
 * - /ingredientCategories/{categoryId}: Global list of ingredient categories.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access is granted to the 'allergens' and 'ingredientCategories' collections.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 * - Enforces ownership on create, update, and delete operations for user-owned data.
 * - Requires the userId to be included in the data and to match the authenticated user's ID for all user-owned data.
 *
 * Denormalization for Authorization:
 * - Each document in collections like 'outlets', 'suppliers', 'inventory', 'recipes', 'menus', 'sales', and 'purchaseOrders' includes a 'userId' field
 *   that is used to enforce ownership. This avoids costly `get()` calls to a separate user profile document.
 *
 * Structural Segregation:
 * - The application uses separate collections for public (allergens, ingredientCategories) and private (user-owned) data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can only read/write their own profile.
     * @path /users/{userId}
     * @allow (create) - Authenticated user creates their own profile. request.auth.uid == userId
     * @allow (get, update, delete) - Authenticated user reads/updates/deletes their own profile. request.auth.uid == userId
     * @deny (create) - User attempts to create a profile with a different userId.
     * @deny (update, delete) - User attempts to update/delete another user's profile.
     * @deny (list) - Listing users is not allowed.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Never list all users
      allow create: if isOwner(userId);
      // Prevent changing the userId (path param already immutable, but double guard request body)
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure outlets. Users can only manage outlets they own.
     * @path /outlets/{outletId}
     * @allow (create) - Authenticated user creates an outlet with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own outlets. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create an outlet with a different userId.
     * @deny (update, delete) - User attempts to update/delete an outlet they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /outlets/{outletId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure suppliers. Users can only manage suppliers they own.
     * @path /suppliers/{supplierId}
     * @allow (create) - Authenticated user creates a supplier with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own suppliers. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a supplier with a different userId.
     * @deny (update, delete) - User attempts to update/delete a supplier they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /suppliers/{supplierId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure inventory items. Users can only manage inventory items they own.
     * @path /inventory/{inventoryId}
     * @allow (create) - Authenticated user creates an inventory item with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own inventory items. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create an inventory item with a different userId.
     * @deny (update, delete) - User attempts to update/delete an inventory item they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /inventory/{inventoryId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure inventory stock levels. Users can only manage stock levels associated with their outlets/items.
     * @path /inventoryStock/{stockId}
     * @allow (create) - Authenticated user creates a stock level with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes stock levels for their outlets/items. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a stock level with a different userId.
     * @deny (update, delete) - User attempts to update/delete a stock level they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /inventoryStock/{stockId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure recipes. Users can only manage recipes they own.
     * @path /recipes/{recipeId}
     * @allow (create) - Authenticated user creates a recipe with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own recipes. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a recipe with a different userId.
     * @deny (update, delete) - User attempts to update/delete a recipe they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /recipes/{recipeId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure menus. Users can only manage menus they own.
     * @path /menus/{menuId}
     * @allow (create) - Authenticated user creates a menu with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own menus. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a menu with a different userId.
     * @deny (update, delete) - User attempts to update/delete a menu they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /menus/{menuId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure sales records. Users can only manage sales records associated with their outlets.
     * @path /sales/{saleId}
     * @allow (create) - Authenticated user creates a sale record with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes sales records for their outlets. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a sale record with a different userId.
     * @deny (update, delete) - User attempts to update/delete a sale record they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /sales/{saleId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Secure purchase orders. Users can only manage purchase orders they own.
     * @path /purchaseOrders/{poId}
     * @allow (create) - Authenticated user creates a purchase order with their userId. request.auth.uid == request.resource.data.userId
     * @allow (get, list, update, delete) - Authenticated user reads/lists/updates/deletes their own purchase orders. request.auth.uid == resource.data.userId
     * @deny (create) - User attempts to create a purchase order with a different userId.
     * @deny (update, delete) - User attempts to update/delete a purchase order they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /purchaseOrders/{poId} {
      allow get: if canReadOwned();
      allow list: if canListOwned();
      allow create: if canCreateOwned();
      allow update: if canUpdateOwned();
      allow delete: if canDeleteOwned();
    }

    /**
     * @description Public read access for allergens.
     * @path /allergens/{allergenId}
     * @allow (get, list) - Anyone can read the list of allergens.
     * @deny (create, update, delete) - Only admins can modify the list of allergens.
     * @principle Public read access with restricted writes.
     */
    match /allergens/{allergenId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation if needed
    }

    /**
     * @description Public read access for ingredient categories.
     * @path /ingredientCategories/{categoryId}
     * @allow (get, list) - Anyone can read the list of ingredient categories.
     * @deny (create, update, delete) - Only admins can modify the list of ingredient categories.
     * @principle Public read access with restricted writes.
     */
    match /ingredientCategories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation if needed
    }

    // ----- Helper Functions -----
    // Basic auth checks
    function isSignedIn() { return request.auth != null; }
    function isOwner(userId) { return isSignedIn() && request.auth.uid == userId; }
    function isExistingOwner(userId) { return isOwner(userId) && resource != null; }

    // Require a userId field on create and that it matches the authenticated user
    function hasValidCreateUserId() {
      return request.resource.data.userId is string && request.resource.data.userId == request.auth.uid;
    }

    // Enforce immutability of userId on update
    function userIdUnchanged() {
      return request.resource.data.userId == resource.data.userId;
    }

    // Limit result set size (if client sets limit). If no limit specified, allow but could enforce a default by requiring limit.
    function withinListLimit() {
      return !("limit" in request.query) || request.query.limit <= 100;
    }

    // Generic ownership-based capability helpers for user-owned collections
    function canReadOwned() { return isOwner(resource.data.userId); }
    function canListOwned() { return canReadOwned() && withinListLimit(); }
    function canCreateOwned() { return hasValidCreateUserId(); }
    function canUpdateOwned() { return isExistingOwner(resource.data.userId) && userIdUnchanged(); }
    function canDeleteOwned() { return isExistingOwner(resource.data.userId); }
  }
}